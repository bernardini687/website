<!doctype html>
<html lang="en">
  <head>
    <title>Step By Step Through Merge Sort</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="/assets/css/styles.css">
  </head>
  <body>
    <main>
      <h1>Step By Step Through Merge Sort</h1>
      <header>
        <nav>
  <ul>
  
    
      <li><a href="/">index</a></li>
    
  
    
      <li><a href="/about.html">about</a></li>
    
  
    
      <li><a href="/blog.html">blog</a></li>
    
  
  </ul>
</nav>

      </header>
      <section>
        <h1>Step By Step Through Merge Sort</h1>
<p class="color-light sans">05 Aug 2019</p>

<article>
  <p>Hello friend. Having trouble puzzling out <strong>merge sort</strong>? Me too, but together we can do it!</p>

<p>First of all, hereâ€™s the algorithm written in Ruby from <a href="https://rosettacode.org/wiki/Sorting_algorithms/Merge_sort#Ruby">rosettacode.org</a>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def merge_sort(m)
  return m if m.length &lt;= 1

  middle = m.length / 2
  left = merge_sort(m[0...middle])
  right = merge_sort(m[middle..-1])
  merge(left, right)
end

def merge(left, right)
  result = []
  until left.empty? || right.empty?
    result &lt;&lt; (left.first &lt;= right.first ? left.shift : right.shift)
  end
  result + left + right
end
</code></pre></div></div>

<p>Thatâ€™s nice. Weâ€™ll be much more confident looking at it by the end of this post, trust me.</p>

<p>Letâ€™s start simple. Merge sort is about sorting elements so hereâ€™s the simplest list we can have:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>list = []
</code></pre></div></div>

<p>Okay, letâ€™s sort this!</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>merge_sort [] # =&gt; []
</code></pre></div></div>

<p>Makes sense. According to the first line in <code class="highlighter-rouge">merge_sort</code> Iâ€™m also expecting that an array of size one will be returned as it is.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>merge_sort [rand(2)] # =&gt; [1]
</code></pre></div></div>

<p>Okay, arrays with one or zero elements are already sorted, thatâ€™s clear. And theyâ€™re also the <strong>base case</strong> of our recursive calls to <code class="highlighter-rouge">merge_sort</code>. Lists greater than them will be divided until theyâ€™ll be that small, and then feed into another method, <code class="highlighter-rouge">merge</code>, that will handle the actual sorting. Weâ€™re going to deal with it.</p>

<p>What if we give ourself a slightly more exciting input? Letâ€™s sort a random list of 2 elements:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>list = (0..9).to_a.sample(2) # =&gt; [5, 3]
merge_sort(list)             # =&gt; [3, 5]
</code></pre></div></div>

<p>Letâ€™s figure out what happend now that we passed through that first <strong>guard clause</strong>.</p>

<p><code class="highlighter-rouge">middle</code> is assigned to half the size of the array so that we can conveniently split it in half. We recursively call <code class="highlighter-rouge">merge_sort</code> again, feeding it each half of the original list and assigning the returning value to the variables <code class="highlighter-rouge">left</code> and <code class="highlighter-rouge">right</code>. With those two juicy arrays we feed another method: <code class="highlighter-rouge">merge</code>, which gives us the sorted list we are craving for.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>list                      # =&gt; [5, 3]
middle = list.size / 2    # =&gt; 1

lhalf = list[0...middle]  # =&gt; [5]
rhalf = list[middle..-1]  # =&gt; [3]

left = merge_sort(lhalf)  # =&gt; [5]
right = merge_sort(rhalf) # =&gt; [3]

merge(left, right)        # =&gt; [3, 5]
</code></pre></div></div>

<p>Interesting. So now, whatâ€™s <code class="highlighter-rouge">merge</code> doing? Letâ€™s see, it first assigns an empty array to <code class="highlighter-rouge">result</code>, pushing inside the return value of a ternary operator, until one of the given argument becomes empty.</p>

<p>So, if the first element of <code class="highlighter-rouge">left</code> (5) is less-than-or-equal-to the first element of <code class="highlighter-rouge">right</code> (3), we call <code class="highlighter-rouge">#shift</code> on it and push the first element of that array in <code class="highlighter-rouge">result</code>. Of course 5 is not less-than-or-equal-to 3 so we shift on <code class="highlighter-rouge">right</code>, which now becomes empty (remember that <code class="highlighter-rouge">#shift</code> removes the first element of the array itâ€™s called upon) and thus breaking from the loop:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>result &lt;&lt; (left.first &lt;= right.first ? left.shift : right.shift)
result                # =&gt; [3]

left                  # =&gt; [5]
right                 # =&gt; []

result + left + right # =&gt; [3, 5]
# [3]  + [5]  + []
</code></pre></div></div>

<p>We have all the basic elements now to understand more lengthy calls to <code class="highlighter-rouge">merge_sort</code>. Letâ€™s break down with some <strong>pseudopseudocode</strong> what would happen with a list of 3 elements:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Sort [5, 4, 3]
  Split [5, 4, 3] into [5] and [4, 3]

  We know how 1 element lists get sorted:
  Sort [5] returns [5]

  We also know how a list of 2 elements gets sorted:
  Sort [4, 3]
    Split [4, 3] into [4] and [3]

    Sort [4] returns [4]
    Sort [3] returns [3]

    Merge [4] and [3]
      4 comes after 3 so shift 3 and have [3]
      Nothing left to compare 4 with so let's add what remains and have [3, 4]

    We still have [5] hanging around so:
    Merge [5] and [3, 4]
      5 comes after 3 so shift 3 and have [3]
      5 comes after 4 so shif 4 and have [3, 4]
      Nothing left to compare 5 with so let's add what remains and have [3, 4, 5]
</code></pre></div></div>

<p>Or, more schematically:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[5, 3, 4] -&gt; merge_sort

..[5] &lt;-

..[3, 4] -&gt; merge_sort
.....[3] &lt;-
.....[4] &lt;-

.....[3], [4] -&gt; merge
..[3, 4] &lt;-

..[5], [3, 4] -&gt; merge
[3, 4, 5] &lt;- ðŸŽ‰
</code></pre></div></div>

<p>One last example of what happens with a 4 elements list:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[5, 3, 0, 4] -&gt; merge_sort

..[5, 3] -&gt; merge_sort
.....[5] &lt;-
.....[3] &lt;-

.....[5], [3] -&gt; merge
..[3, 5] &lt;-

..[0, 4] -&gt; merge_sort
.....[0] &lt;-
.....[4] &lt;-

.....[0], [4] -&gt; merge
..[0, 4] &lt;-

..[3, 5], [0, 4] -&gt; merge
[0, 3, 4, 5] &lt;- ðŸŽ‰
</code></pre></div></div>

<p>Hope at least somethingâ€™s more clear by now. If not, my mistake!</p>

</article>

      </section>
    </main>
  </body>
</html>
